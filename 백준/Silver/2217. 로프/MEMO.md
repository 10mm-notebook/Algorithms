# [백준 2217] 로프 - Python

## 📌 문제 설명

N 개의 로프가 주어질 때, 이 로프들을 이용해 들어올릴 수 있는 **물체의 최대 중량**을 구하는 문제입니다.

* 모든 로프를 사용할 필요는 없으며, 임의로 몇 개의 로프를 골라 사용할 수 있습니다.
* k 개의 로프를 병렬로 연결하면 각각의 로프에는 w/k 만큼의 동일한 하중이 걸립니다.

---

## 🔍 접근 방식 및 해결 과정

### 1단계: 첫 번째 접근 (논리 오류)

처음에는 단순히 (가장 약한 로프의 무게) × (전체 로프의 개수)로 계산했습니다. 하지만 문제의 조건 중 "모든 로프를 사용해야 할 필요는 없다"는 점을 놓쳤습니다.

> **오류 케이스:** 로프가 `[1, 100]`인 경우, 1짜리 로프를 버리고 100짜리 하나만 쓰는 것이 훨씬 유리함.

### 2단계: 두 번째 접근 (시간 초과 - O(N^2))

모든 경우의 수를 고려하기 위해 로프를 정렬한 후, 반복문을 통해 슬라이싱(`ropes[0:k]`)과 `min()` 함수를 사용했습니다.

* **원인:** 반복문 안에서 리스트를 슬라이싱하고 최소값을 찾는 과정이 추가되어 시간 복잡도가 O(N^2)까지 치솟았습니다. 이 100,000일 때 100억 번의 연산이 필요하므로 **시간 초과(TLE)**가 발생했습니다.

### 3단계: 최종 최적화 (성공 - O(N log N))

"정렬"의 특성을 활용하여 불필요한 연산을 제거했습니다.

1. 로프를 내림차순(큰 순서대로)으로 정렬합니다.
2. 정렬된 리스트에서 k번째 로프는 0번부터 k번까지의 로프 중 가장 약한 로프가 됩니다.
3. 따라서 `현재 로프의 무게 × (k + 1)`을 계산하면, 별도의 `min()` 함수 없이도 해당 로프들을 사용했을 때의 최대 중량을 바로 구할 수 있습니다.

---

## 💻 최종 코드

```python
import sys

# 입력 속도 향상
N = int(sys.stdin.readline())

ropes = []
max_weight = 0

# 로프 정보 입력
for i in range(N):
    ropes.append(int(sys.stdin.readline()))

# 1. 내림차순 정렬 (큰 것부터 선택하기 위함)
ropes.sort(reverse=True)

# 2. 그리디 알고리즘 적용
for k in range(0, N):
    # k번째 로프를 가장 약한 로프로 가정했을 때의 최대 중량 계산
    # (k+1)은 현재까지 선택한 로프의 개수
    temp = ropes[k] * (k + 1)
    max_weight = max(max_weight, temp)

print(max_weight)

```

---

## ⏱️ 시간 복잡도 분석

1. **입력부:** O(N)
2. **정렬 (`sort`):** Python의 Timsort를 사용하여 **O(N log N)**이 소요됩니다.
3. **연산 (반복문):** 리스트를 한 번만 순회하므로 **O(N)**이 소요됩니다.

* **최종 시간 복잡도:** O(N log N) + O(N) = O(N log N)
* N=100,000일 때 약 1,600,000번의 연산으로 제한 시간 2초 내에 넉넉히 통과 가능합니다.

---

## 💡 깨달은 점

* 단순히 정답을 맞히는 것보다 **시간 복잡도를 고려한 자료구조 및 함수 사용**이 얼마나 중요한지 배웠습니다.
* 특히 정렬된 상태에서는 인덱스 자체가 이미 순서를 보장하므로, `min()`이나 슬라이싱 같은 추가 연산을 획기적으로 줄일 수 있다는 점을 체감했습니다.

---
