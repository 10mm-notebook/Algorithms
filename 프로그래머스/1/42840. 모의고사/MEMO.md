# [Programmers] Level 1 - 모의고사 (Python) 풀이 과정 및 접근법 기록

## 1. 문제 정보

**날짜:** 2026. 02. 15 


**출처:** 프로그래머스 - Level 1 모의고사 


**핵심 알고리즘:** 완전 탐색 (Brute Force), 시뮬레이션

## 2. 문제 설명

3명의 수포자가 정해진 규칙에 따라 답을 찍을 때, 가장 많은 문제를 맞힌 사람이 누구인지 찾는 문제입니다. 

**수포자 1번 패턴:** `1, 2, 3, 4, 5` (5개 주기) 


**수포자 2번 패턴:** `2, 1, 2, 3, 2, 4, 2, 5` (8개 주기) 


**수포자 3번 패턴:** `3, 3, 1, 1, 2, 2, 4, 4, 5, 5` (10개 주기)  


**출력:** 가장 높은 점수를 받은 사람을 배열에 담아 리턴하며, 동점자일 경우 오름차순으로 정렬합니다. 



## 3. 접근 방식 및 사고 과정

1. **데이터 구조 설계:** 수포자들의 점수를 관리하기 위해 딕셔너리(`score_dict`)를 활용하여 각 이름(Key)과 점수(Value)를 매칭했습니다. 


2. **답안지 생성:** 입력된 `answers`의 길이만큼 각 수포자의 패턴을 확장하여 전체 답안 리스트를 생성했습니다. 


`(패턴 * 반복횟수) + (남은 패턴 슬라이싱)` 방식을 사용하여 길이를 맞췄습니다. 


3. **채점 로직:** 반복문을 통해 수포자의 답안과 실제 `answers`를 비교하며 일치할 경우 점수를 1씩 증가시켰습니다. 


4. **결과 도출:** `max()` 함수로 최고 점수를 구한 뒤, 해당 점수와 일치하는 수포자 번호를 결과 리스트에 담았습니다. 



## 4. 시행착오 및 해결 (Troubleshooting)

**변수 명명 규칙 오류:** 처음에는 `1st_pattern` 등 숫자로 시작하는 변수명을 사용했으나, 파이썬 변수명 규칙 위반으로 인한 `SyntaxError`를 확인하고 `first_pattern`으로 수정했습니다.

**Starred Expression 오류:** 리스트 내부에서 `(*pattern)`과 같은 형식을 시도했으나 구문 오류가 발생하여, 리스트 곱셈(`*`)과 덧셈(`+`) 연산으로 해결했습니다. 

**입력 처리 오류:** 테스트 환경에서 `solution(input())`을 직접 호출할 때 `EOFError`가 발생함을 인지하고, 시스템이 함수를 직접 호출하도록 구조를 변경했습니다.

**딕셔너리 초기화:** `score_dict["key"] += 1`을 수행하기 전, 반드시 초기값(`0`)을 설정해야 함을 체득했습니다. 


## 5. 복잡도 분석
 
**시간 복잡도:**  

`answers`의 길이에 비례하여 시트를 생성하고 한 번의 루프로 채점을 완료하므로 선형 시간에 해결 가능합니다.

**공간 복잡도:** 
입력 길이에 비례하는 3개의 리스트(`sheet1`, `sheet2`, `sheet3`)를 생성하므로 $O(n)$의 공간이 필요합니다.



6. 학습 및 개선점 

- 리스트끼리 더할 때 `+` 연산자를 사용하는 편리함을 확인했습니다. 

- 딕셔너리(`dict`)를 호출하고 `max(dict.values())`를 활용하는 방법을 익혔습니다. 

- 다음에는 나머지 연산자(`%`)를 활용하여 공간 복잡도를 $O(1)$로 줄이는 방식을 적용해 볼 예정입니다. 
